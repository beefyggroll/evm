import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import time
import random
from typing import List, Tuple, Optional
import copy

class KnightTourSolver:
    def __init__(self, n: int, m: int):
        self.n = n
        self.m = m
        self.board = [[-1 for _ in range(m)] for _ in range(n)]
        self.moves = [
            (2, 1), (2, -1), (-2, 1), (-2, -1),
            (1, 2), (1, -2), (-1, 2), (-1, -2)
        ]
        self.all_solutions = []
    
    def is_valid_move(self, x: int, y: int) -> bool:
        return 0 <= x < self.n and 0 <= y < self.m and self.board[x][y] == -1
    
    def get_valid_moves(self, x: int, y: int) -> List[Tuple[int, int]]:
        valid_moves = []
        for dx, dy in self.moves:
            new_x, new_y = x + dx, y + dy
            if self.is_valid_move(new_x, new_y):
                valid_moves.append((new_x, new_y))
        return valid_moves
    
    def warnsdorff_heuristic(self, x: int, y: int) -> int:
        """Количество доступных ходов из следующей позиции (правило Варнсдорфа)"""
        return len(self.get_valid_moves(x, y))
    
    def solve_knights_tour(self, start_x: int, start_y: int) -> Optional[List[List[int]]]:
        """Решение задачи о ходе коня с использованием эвристики Варнсдорфа"""
        board_copy = [row[:] for row in self.board]  
        
        x, y = start_x, start_y
        self.board[x][y] = 1
        
        for move_number in range(2, self.n * self.m + 1):
            next_moves = self.get_valid_moves(x, y)
            
            if not next_moves:
                self.board = board_copy  
                return None  
            
            next_moves.sort(key=lambda pos: self.warnsdorff_heuristic(pos[0], pos[1]))
            
            x, y = next_moves[0]
            self.board[x][y] = move_number
        
        solution = [row[:] for row in self.board]  
        self.board = board_copy  
        return solution
    
    def solve_with_backtracking(self, start_x: int, start_y: int) -> Optional[List[List[int]]]:
        """Решение с возвратом для более надежного поиска"""
        board_copy = [row[:] for row in self.board]  
        self.board[start_x][start_y] = 1
        
        def backtrack(x: int, y: int, move_count: int) -> bool:
            if move_count == self.n * self.m:
                return True
            
            next_moves = self.get_valid_moves(x, y)
            next_moves.sort(key=lambda pos: self.warnsdorff_heuristic(pos[0], pos[1]))
            
            for next_x, next_y in next_moves:
                self.board[next_x][next_y] = move_count + 1
                if backtrack(next_x, next_y, move_count + 1):
                    return True
                self.board[next_x][next_y] = -1  
            
            return False
        
        result = backtrack(start_x, start_y, 1)
        if result:
            solution = [row[:] for row in self.board]  
            self.board = board_copy  
            return solution
        self.board = board_copy  
        return None

    def find_all_solutions(self, start_x: int, start_y: int, max_solutions: int = 1000) -> List[List[List[int]]]:
        """Поиск всех возможных решений (с ограничением количества)"""
        self.all_solutions = []
        
        def backtrack_all(x: int, y: int, move_count: int, board: List[List[int]]):
            if len(self.all_solutions) >= max_solutions:
                return
            
            if move_count == self.n * self.m:
                solution = copy.deepcopy(board)
                self.all_solutions.append(solution)
                return
            
            next_moves = []
            for dx, dy in self.moves:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < self.n and 0 <= new_y < self.m and board[new_x][new_y] == -1:
                    next_moves.append((new_x, new_y))
            
            def get_degree(pos):
                count = 0
                for dx, dy in self.moves:
                    nx, ny = pos[0] + dx, pos[1] + dy
                    if 0 <= nx < self.n and 0 <= ny < self.m and board[nx][ny] == -1:
                        count += 1
                return count
            
            next_moves.sort(key=get_degree)
            
            for next_x, next_y in next_moves:
                board[next_x][next_y] = move_count + 1
                backtrack_all(next_x, next_y, move_count + 1, board)
                board[next_x][next_y] = -1  
        
        initial_board = [[-1 for _ in range(self.m)] for _ in range(self.n)]
        initial_board[start_x][start_y] = 1
        backtrack_all(start_x, start_y, 1, initial_board)
        return self.all_solutions


class KnightTourGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Задача о ходе коня")
        self.root.geometry("700x700")
        
        self.setup_gui()
        self.solution = None
        self.all_solutions = []
        self.current_solution_index = 0
        self.current_move = 0
        self.animation_id = None
        
    def setup_gui(self):
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        input_frame = ttk.LabelFrame(main_frame, text="Параметры доски", padding="10")
        input_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        ttk.Label(input_frame, text="Ширина доски (n):").grid(row=0, column=0, sticky=tk.W)
        self.n_var = tk.StringVar(value="5")
        self.n_spinbox = ttk.Spinbox(input_frame, from_=3, to=8, textvariable=self.n_var, width=10)
        self.n_spinbox.grid(row=0, column=1, padx=(5, 15))
        
        ttk.Label(input_frame, text="Высота доски (m):").grid(row=0, column=2, sticky=tk.W)
        self.m_var = tk.StringVar(value="5")
        self.m_spinbox = ttk.Spinbox(input_frame, from_=3, to=8, textvariable=self.m_var, width=10)
        self.m_spinbox.grid(row=0, column=3, padx=(5, 15))
        
        ttk.Label(input_frame, text="Начальная позиция X:").grid(row=1, column=0, sticky=tk.W, pady=(10, 0))
        self.start_x_var = tk.StringVar(value="0")
        self.start_x_spinbox = ttk.Spinbox(input_frame, from_=0, to=7, textvariable=self.start_x_var, width=10)
        self.start_x_spinbox.grid(row=1, column=1, padx=(5, 15), pady=(10, 0))
        
        ttk.Label(input_frame, text="Начальная позиция Y:").grid(row=1, column=2, sticky=tk.W, pady=(10, 0))
        self.start_y_var = tk.StringVar(value="0")
        self.start_y_spinbox = ttk.Spinbox(input_frame, from_=0, to=7, textvariable=self.start_y_var, width=10)
        self.start_y_spinbox.grid(row=1, column=3, padx=(5, 15), pady=(10, 0))
        
        ttk.Label(input_frame, text="Макс. решений:").grid(row=2, column=0, sticky=tk.W, pady=(10, 0))
        self.max_solutions_var = tk.StringVar(value="100")
        self.max_solutions_spinbox = ttk.Spinbox(input_frame, from_=1, to=1000, textvariable=self.max_solutions_var, width=10)
        self.max_solutions_spinbox.grid(row=2, column=1, padx=(5, 15), pady=(10, 0))
        
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=1, column=0, pady=(10, 10))
        
        self.find_all_btn = ttk.Button(button_frame, text="Найти решения", command=self.find_all_solutions)
        self.find_all_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        self.animate_btn = ttk.Button(button_frame, text="Анимировать", command=self.animate_solution, state=tk.DISABLED)
        self.animate_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        self.prev_btn = ttk.Button(button_frame, text="← Предыдущее", command=self.previous_solution, state=tk.DISABLED)
        self.prev_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        self.next_btn = ttk.Button(button_frame, text="Следующее →", command=self.next_solution, state=tk.DISABLED)
        self.next_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        self.reset_btn = ttk.Button(button_frame, text="Сбросить", command=self.reset)
        self.reset_btn.pack(side=tk.LEFT)
        
        board_container = ttk.Frame(main_frame)
        board_container.grid(row=2, column=0, pady=20, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        self.board_frame = ttk.LabelFrame(board_container, text="Шахматная доска", padding="10")
        self.board_frame.pack(expand=True)
        
        info_frame = ttk.Frame(main_frame)
        info_frame.grid(row=3, column=0, sticky=(tk.W, tk.E), pady=(10, 0))
        
        self.solutions_info_var = tk.StringVar(value="Всего решений: 0")
        ttk.Label(info_frame, textvariable=self.solutions_info_var, font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        
        self.current_solution_var = tk.StringVar(value=" | Текущее решение: 0/0")
        ttk.Label(info_frame, textvariable=self.current_solution_var, font=("Arial", 9)).pack(side=tk.LEFT, padx=(20, 0))
        
        self.status_var = tk.StringVar(value="Готов к работе")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, relief=tk.SUNKEN)
        status_bar.grid(row=4, column=0, sticky=(tk.W, tk.E), pady=(10, 0))
        
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(2, weight=1)
        board_container.columnconfigure(0, weight=1)
        board_container.rowconfigure(0, weight=1)
        
    def create_board(self, n: int, m: int):
        """Создание графического представления доски"""
        for widget in self.board_frame.winfo_children():
            widget.destroy()
        
        canvas_width = min(500, m * 60)
        canvas_height = min(500, n * 60)
        self.canvas = tk.Canvas(self.board_frame, width=canvas_width, height=canvas_height, 
                               bg='white', highlightthickness=1, highlightbackground="black")
        self.canvas.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        self.cell_size = min(canvas_width // m, canvas_height // n, 60)
        self.cells = [[None for _ in range(m)] for _ in range(n)]
        
        for i in range(n):
            for j in range(m):
                x1 = j * self.cell_size
                y1 = i * self.cell_size
                x2 = x1 + self.cell_size
                y2 = y1 + self.cell_size
                
                color = "#F0D9B5" if (i + j) % 2 == 0 else "#B58863"
                rect = self.canvas.create_rectangle(x1, y1, x2, y2, fill=color, outline="black")
                self.cells[i][j] = rect
        
        self.board_frame.update()
    
    def find_all_solutions(self):
        """Поиск всех возможных решений"""
        try:
            n = int(self.n_var.get())
            m = int(self.m_var.get())
            start_x = int(self.start_x_var.get())
            start_y = int(self.start_y_var.get())
            max_solutions = int(self.max_solutions_var.get())
            
            if not (0 <= start_x < n and 0 <= start_y < m):
                messagebox.showerror("Ошибка", "Начальная позиция должна быть в пределах доски")
                return
            
            self.status_var.set("Поиск решений")
            self.root.update()
            
            self.create_board(n, m)
            
            solver = KnightTourSolver(n, m)
            self.all_solutions = solver.find_all_solutions(start_x, start_y, max_solutions)
            
            if self.all_solutions:
                self.current_solution_index = 0
                self.current_move = 0
                self.solution = self.all_solutions[0]
                self.display_solution()
                self.update_solutions_info()
                
                self.animate_btn.config(state=tk.NORMAL)
                self.prev_btn.config(state=tk.NORMAL if len(self.all_solutions) > 1 else tk.DISABLED)
                self.next_btn.config(state=tk.NORMAL if len(self.all_solutions) > 1 else tk.DISABLED)
                
                self.status_var.set(f"Найдено решений: {len(self.all_solutions)}")
                
                if len(self.all_solutions) == max_solutions:
                    messagebox.showwarning("Внимание", 
                                         f"Достигнуто максимальное количество решений ({max_solutions}).\n"
                                         f"Возможно, существуют дополнительные решения.")
            else:
                self.solution = None
                self.animate_btn.config(state=tk.DISABLED)
                self.prev_btn.config(state=tk.DISABLED)
                self.next_btn.config(state=tk.DISABLED)
                self.status_var.set("Решения не найдены")
                messagebox.showinfo("Результат", "Решения не найдены для данных параметров доски и начальной позиции")
                
        except ValueError:
            messagebox.showerror("Ошибка", "Пожалуйста, введите корректные числовые значения")
    
    def update_solutions_info(self):
        """Обновление информации о решениях"""
        total = len(self.all_solutions)
        current = self.current_solution_index + 1
        self.solutions_info_var.set(f"Всего решений: {total}")
        self.current_solution_var.set(f" | Текущее решение: {current}/{total}")
    
    def display_solution(self, move_number: int = None):
        """Отображение решения на доске"""
        if not self.solution:
            return
        
        n = len(self.solution)
        m = len(self.solution[0])
        
        if move_number is None:
            move_number = n * m
        
        self.canvas.delete("numbers")
        self.canvas.delete("knight")
        
        for i in range(n):
            for j in range(m):
                cell_value = self.solution[i][j]
                if cell_value != -1 and cell_value <= move_number:
                    x = j * self.cell_size + self.cell_size // 2
                    y = i * self.cell_size + self.cell_size // 2
                    
                    if cell_value == move_number:
                        self.canvas.create_oval(x-15, y-15, x+15, y+15, fill="red", outline="darkred", tags="knight")
                        self.canvas.create_text(x, y, text=str(cell_value), 
                                              fill="white", font=("Arial", 10, "bold"), tags="numbers")
                    else:
                        self.canvas.create_text(x, y, text=str(cell_value), 
                                              fill="black", font=("Arial", 8), tags="numbers")
    
    def animate_solution(self):
        """Анимация решения"""
        if not self.solution:
            return
        
        total_moves = len(self.solution) * len(self.solution[0])
        
        if self.current_move < total_moves:
            self.display_solution(self.current_move + 1)
            self.current_move += 1
            self.animation_id = self.root.after(300, self.animate_solution)  # Задержка 300 мс
        else:
            self.current_move = 0
            self.animate_btn.config(state=tk.NORMAL)
    
    def previous_solution(self):
        """Переход к предыдущему решению"""
        if len(self.all_solutions) > 1:
            self.current_solution_index = (self.current_solution_index - 1) % len(self.all_solutions)
            self.solution = self.all_solutions[self.current_solution_index]
            self.current_move = 0
            self.display_solution()
            self.update_solutions_info()
            self.animate_btn.config(state=tk.NORMAL)
    
    def next_solution(self):
        """Переход к следующему решению"""
        if len(self.all_solutions) > 1:
            self.current_solution_index = (self.current_solution_index + 1) % len(self.all_solutions)
            self.solution = self.all_solutions[self.current_solution_index]
            self.current_move = 0
            self.display_solution()
            self.update_solutions_info()
            self.animate_btn.config(state=tk.NORMAL)
    
    def reset(self):
        """Сброс доски"""
        if self.animation_id:
            self.root.after_cancel(self.animation_id)
            self.animation_id = None
        
        self.solution = None
        self.all_solutions = []
        self.current_solution_index = 0
        self.current_move = 0
        self.animate_btn.config(state=tk.DISABLED)
        self.prev_btn.config(state=tk.DISABLED)
        self.next_btn.config(state=tk.DISABLED)
        self.status_var.set("Готов к работе")
        self.solutions_info_var.set("Всего решений: 0")
        self.current_solution_var.set(" | Текущее решение: 0/0")
        
        if hasattr(self, 'canvas'):
            self.canvas.delete("numbers")
            self.canvas.delete("knight")
    
    def run(self):
        """Запуск приложения"""
        self.root.mainloop()

if __name__ == "__main__":
    app = KnightTourGUI()
    app.run()
