import numpy as np

def f(x):
    return ((x**2 - 3) * np.cbrt(x - 1.2) / (x - 0.5)) - 2 * x

def left_rectangle_rule(func, a, b, n):
    h = (b - a) / n
    x_nodes = a + np.arange(n) * h  # Ð›ÐµÐ²Ñ‹Ðµ ÐºÐ¾Ð½Ñ†Ñ‹ Ð¸Ð½Ñ‚ÐµÑ€Ð²Ð°Ð»Ð¾Ð²
    y_values = func(x_nodes)
    integral = h * np.sum(y_values)
    return integral

def estimate_order(prev_I, curr_I, next_I):
    # Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ñ‚Ñ€Ð¸ Ð¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… Ð¿Ñ€Ð¸Ð±Ð»Ð¸Ð¶ÐµÐ½Ð¸Ñ Ð´Ð»Ñ Ð¾Ñ†ÐµÐ½ÐºÐ¸ Ð¿Ð¾Ñ€ÑÐ´ÐºÐ° Ð¿Ð¾ Ð­Ð¹Ñ‚ÐºÐµÐ½Ñƒ
    # ÐÐ° Ð¾ÑÐ½Ð¾Ð²Ðµ ÑÐ¾Ð¾Ñ‚Ð½Ð¾ÑˆÐµÐ½Ð¸Ñ: I â‰ˆ I_h + C * h^p
    # ÐŸÑ€Ð¸ h -> h/2: I_h - I â‰ˆ C * h^p, I_h/2 - I â‰ˆ C * (h/2)^p
    # => (I_h - I_h/2) / (I_h/2 - I_h/4) â‰ˆ 2^p
    if abs(curr_I - next_I) < 1e-15:
        return float('inf')
    ratio = (prev_I - curr_I) / (curr_I - next_I)
    if ratio <= 0:
        return float('nan')
    p = np.log2(ratio)
    return p

def main():
    a, b = 0.6, 4.0
    eps = 1e-4
    max_iter = 20

    print("Ð’Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ðµ Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð°Ð»Ð° Ð¼ÐµÑ‚Ð¾Ð´Ð¾Ð¼ Ð»ÐµÐ²Ñ‹Ñ… Ð¿Ñ€ÑÐ¼Ð¾ÑƒÐ³Ð¾Ð»ÑŒÐ½Ð¸ÐºÐ¾Ð²")
    print(f"f(x) = ((xÂ² - 3) * âˆ›(x - 1.2)) / (x - 0.5) - 2x")
    print(f"Ð˜Ð½Ñ‚ÐµÑ€Ð²Ð°Ð»: [{a}, {b}], Ñ‚Ð¾Ñ‡Ð½Ð¾ÑÑ‚ÑŒ: {eps}\n")

    n = 10
    I_prev = None
    I_curr = None
    results = []

    for iteration in range(max_iter):
        I_next = left_rectangle_rule(f, a, b, n)

        error_est = abs(I_next - I_curr) if I_curr is not None else None
        order = None

        if I_prev is not None and I_curr is not None:
            order = estimate_order(I_prev, I_curr, I_next)

        results.append((iteration, n, I_next, error_est, order))

        # Ð’Ñ‹Ð²Ð¾Ð´
        print(f"Ð˜Ñ‚ÐµÑ€Ð°Ñ†Ð¸Ñ {iteration}:")
        print(f"  n = {n}")
        print(f"  Ð˜Ð½Ñ‚ÐµÐ³Ñ€Ð°Ð» â‰ˆ {I_next:.8f}")
        if error_est is not None:
            print(f"  ÐžÑ†ÐµÐ½ÐºÐ° Ð¿Ð¾Ð³Ñ€ÐµÑˆÐ½Ð¾ÑÑ‚Ð¸ = {error_est:.2e}")
        if order is not None:
            if np.isfinite(order):
                print(f"  ÐŸÐ¾Ñ€ÑÐ´Ð¾Ðº Ñ‚Ð¾Ñ‡Ð½Ð¾ÑÑ‚Ð¸ (Ð­Ð¹Ñ‚ÐºÐµÐ½) â‰ˆ {order:.4f}")
            else:
                print(f"  ÐŸÐ¾Ñ€ÑÐ´Ð¾Ðº Ñ‚Ð¾Ñ‡Ð½Ð¾ÑÑ‚Ð¸ â€” Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ (Ñ€Ð°Ð·Ð½Ð¾ÑÑ‚ÑŒ â‰ˆ 0)")
        print("-" * 50)

        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÑ…Ð¾Ð´Ð¸Ð¼Ð¾ÑÑ‚Ð¸
        if error_est is not None and error_est < eps:
            print("âœ… Ð¢Ñ€ÐµÐ±ÑƒÐµÐ¼Ð°Ñ Ñ‚Ð¾Ñ‡Ð½Ð¾ÑÑ‚ÑŒ Ð´Ð¾ÑÑ‚Ð¸Ð³Ð½ÑƒÑ‚Ð°.\n")
            break

        # Ð¡Ð´Ð²Ð¸Ð³ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹
        I_prev = I_curr
        I_curr = I_next
        n *= 2

    else:
        print("âš ï¸ Ð”Ð¾ÑÑ‚Ð¸Ð³Ð½ÑƒÑ‚Ð¾ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾ Ð¸Ñ‚ÐµÑ€Ð°Ñ†Ð¸Ð¹.\n")

    # Ð˜Ñ‚Ð¾Ð³
    final = results[-1]
    print("=== ÐžÐºÐ¾Ð½Ñ‡Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ ===")
    print(f"n = {final[1]}")
    print(f"Ð˜Ð½Ñ‚ÐµÐ³Ñ€Ð°Ð» = {final[2]:.8f}")
    if final[3] is not None:
        print(f"ÐŸÐ¾Ð³Ñ€ÐµÑˆÐ½Ð¾ÑÑ‚ÑŒ â‰ˆ {final[3]:.2e}")
    if final[4] is not None and np.isfinite(final[4]):
        print(f"ÐŸÐ¾Ñ€ÑÐ´Ð¾Ðº Ñ‚Ð¾Ñ‡Ð½Ð¾ÑÑ‚Ð¸ â‰ˆ {final[4]:.4f}")

    # Ð¡Ñ€Ð°Ð²Ð½ÐµÐ½Ð¸Ðµ Ñ Ñ‚Ð¾Ñ‡Ð½Ñ‹Ð¼ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸ÐµÐ¼ (ÐµÑÐ»Ð¸ scipy ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½)
    try:
        from scipy.integrate import quad
        exact, _ = quad(f, a, b)
        true_error = abs(final[2] - exact)
        print(f"\nðŸ” Ð¢Ð¾Ñ‡Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ (scipy): {exact:.8f}")
        print(f"Ð˜ÑÑ‚Ð¸Ð½Ð½Ð°Ñ Ð¿Ð¾Ð³Ñ€ÐµÑˆÐ½Ð¾ÑÑ‚ÑŒ: {true_error:.2e}")
    except ImportError:
        pass  # scipy Ð½Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ â€” Ð¿Ñ€Ð¾Ð¿ÑƒÑÐºÐ°ÐµÐ¼

if __name__ == "__main__":
    main()
